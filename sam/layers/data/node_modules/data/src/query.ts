"use strict";

import DbObject from "./db_object.js";
import DbObjectField, {
  DbObjectStringField,
  DbObjectIdField,
  DbObjectNumberField,
  DbObjectReferenceField,
} from "./db_object_field.js";
import { DbFieldMapper } from "./db_decorators.js";
import Id from "./id.js";
import Timer from "./timer.js";

export class QueryResult {}

export class AggregateQueryResult extends QueryResult {}

export class ObjectQueryResult extends QueryResult {
  #records: DbObject[] = [];

  public constructor(proto: Object) {
    super();
  }
}

export class ConditionalExpression {
  public left: string | ConditionalExpression;
  public operator: string;
  public right: string | ConditionalExpression;

  public constructor(left: string | ConditionalExpression, operator: string, right: string | ConditionalExpression) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
}

export default class Query<T extends DbObject> {
  #queryObject = {};
  #proto: Object;

  static #database: any;
  static async loadDatabase() {
    try {
      // The module name is defined separately from the import to avoid tsc compilation errors
      console.log('Attempting to load database module');
      const module_name = "database-connector";
      const t: Timer = new Timer().start();
      const { default: Database } = await import(module_name);
      console.log(`Loaded module in ${t.stop().elapsedTime()}`);
      this.#database = Database;
    } catch (ex: unknown) {
      if (ex instanceof Error) {
        console.log(`Unable to load database module: ${ex.message}`);
      } else {
        console.log("Unable to load database module");
      }
    }
  }

  constructor(proto: Object) {
    if (!proto) {
      throw new Error("An object prototype must be specified in Query.constructor");
    }
    console.log(`In Query.constructor, class=${proto['name']}`);

    this.#proto = proto;
    this.#queryObject["type"] = "select";
    this.#queryObject["table"] = this.#proto['tableName'];
    this.#queryObject["fields"] = "*";
  }

  select(
    ...fields: (DbObjectField | string)[]
  ): Query<T> {
    if (fields && fields.length) {
      const fieldNames = fields.map(fld => {
        if (typeof fld === "string") return fld;
        if (fld instanceof DbObjectField) return fld.fieldName;
        throw new Error('Provided fields must be strings or instances of DbObjectField');
      });

      if (this.#queryObject["fields"] === "*") {
        this.#queryObject["fields"] = fieldNames;
      } else {
        this.#queryObject["fields"] .push(fieldNames);
      }
    }
    return this;
  }

  public where(expr: ConditionalExpression): Query<T> {
    if (!("where" in this.#queryObject) || !this.#queryObject['where']) {
      this.#queryObject['where'] = expr;
    } else {
      const andExpr = new ConditionalExpression(this.#queryObject['where'] as ConditionalExpression, "AND", expr);
      this.#queryObject['where'] = andExpr;
    }
    return this;
  }

  sort(...fields: string[]|DbObjectField[]): Query<T> {
    this.#queryObject['orderBy'] ||= [];
    this.#queryObject['orderBy'].push(...fields.map(fld => fld.toString()));
    return this;
  }

  sortDown(...fields: string[]|DbObjectField[]): Query<T> {
    this.#queryObject['orderBy'] ||= [];
    this.#queryObject['orderBy'].push(...fields.map(fld => `${fld.toString()} DESC`));
    return this;
  }

  limit(count: number): Query<T> {
    if (((typeof count) !== "number") || ((count | 0) !== count) || (count <= 0)) {
      throw new Error('Value passed to limit must be a positive integer');
    }
    this.#queryObject['limit'] = count;
    //this.#limitClause.setLimit(count);
    return this;
  }

  async all(): Promise<T[]> {
    const objs = [];
    let dbRows: { [index: string]: any }[] = await Query.execute(this.toJSON());
    dbRows.forEach((row: { [index: string]: any }) => {
      // @ts-ignore
      const newObj = this.#proto.newInstance(row);
      objs.push(newObj);
    });
    return objs;
  }

  async count(): Promise<number> {
    const queryCopy = JSON.parse(JSON.stringify(this.toJSON));
    queryCopy["fields"] = "COUNT(*)"
    let res: { [index: string]: any }[] = await Query.execute(queryCopy);
    if (!res || !res.length || !res[0] || !('count' in res[0])) {
      throw new Error('Unknown error while counting records');
    }
    return parseInt(res[0]['count']);
  }

  public toJSON(): object {
    return this.#queryObject;
  }

  private static async execute(q: object): Promise<{ [index: string]: any }[]>
  {
    if (!this.#database) {
      await this.loadDatabase();
    }
    const t = new Timer().start();
    const res = await this.#database!.query(q);
    console.log(`Executed query in ${t.stop().elapsedTime()}`);
    return res;
  }
}