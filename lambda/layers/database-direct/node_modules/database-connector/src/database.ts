import pkg from 'pg';
const { Client } = pkg;

import Transaction, { BasicTransaction } from "./transaction.js";
import QueryFormatter from "./query_formatter.js";

import {
  GetSecretValueCommand,
  SecretsManagerClient,
} from "@aws-sdk/client-secrets-manager";


export default class DatabaseConnector {
  static #connection;
  static #createdConnection: boolean = false;
  static #transactionType: any = BasicTransaction;
  static #transaction: Transaction;

  public static set connection(value: any) {
    console.log('Setting database connection manually');
    if (this.#connection && this.#createdConnection) {
      console.log('Found existing connection, ending it');
      this.#connection.end();
    }
    this.#connection = value;
    this.#createdConnection = false;
  }

  public static set transactionType(value: any) {
    if (this.#transaction && this.#transaction.isOpen()) throw new Error('Transaction type can not be set when there is already an open transaction');
    if (this.#transactionType !== value) {
      console.log(`Setting transaction type to ${value.name}`);
      this.#transaction = undefined;
      this.#transactionType = value;
    }
  }

  public static async query(q: object): Promise<object[]> {
    const sql = QueryFormatter.toSQL(q);
    return this.runSql(sql);
  }

  public static async runSql(sql: string) {
    if (!this.#connection) {
      console.log('We need to create a connection before executing query');
      this.#connection = await this.connect();
      this.#createdConnection = true;
    }
    if (this.#connection) {
      console.trace('About to execute query: ' + sql);
      const res = await this.#connection.query(sql);
      if (res) {
        if (!('rows' in res)) throw new Error('Query result does not have a "rows" value');
        const rows = res.rows;
        console.trace('Query result: ' + JSON.stringify(rows));
        return rows;
      } else {
        console.log(`Query did not return any results: ${JSON.stringify(res)}`)
      }
    }
    return undefined;
  }

  public static async startTransaction(): Promise<void> {
    await this.transaction?.start();
  }

  public static async commitTransaction(): Promise<void> {
    await this.transaction?.commit();
  }

  public static async rollbackTransaction(): Promise<void> {
    await this.transaction?.rollback();
  }

  private static get transaction(): Transaction | undefined {
    if (!this.#transaction) {
      if (!this.#transactionType) throw new Error('Transactions have been disabled for this database connection');
      this.#transaction = new this.#transactionType;
    }
    return this.#transaction;
  }
  private static async connect() {
    const dbSecretName = process.env.DB_SECRET_NAME;
    if (!dbSecretName) throw new Error('Unable to retrieve the name of the database credentials');
    let secret: {[key:string]:string} = await getSecretValue(dbSecretName);

    if (!('host' in secret) || !secret['host']) throw new Error('Database credentials must contain a "host" value');
    if (!('port' in secret) || !secret['port']) throw new Error('Database credentials must contain a "port" value');
    if (!('database_name' in secret) || !secret['database_name']) throw new Error('Database credentials must contain a "database_name" value');
    if (!('username' in secret) || !secret['username']) throw new Error('Database credentials must contain a "username" value');
    if (!('password' in secret) || !secret['password']) throw new Error('Database credentials must contain a "password" value');
    if (!('certificate' in secret) || !secret['certificate']) throw new Error('Database credentials must contain a "certificate" value');

    const pgClient = new Client({
      host: getDatabaseCredential("host", secret),
      port: parseInt(getDatabaseCredential("port", secret)),
      database: getDatabaseCredential("database_name", secret),
      user: getDatabaseCredential("username", secret),
      password: getDatabaseCredential("password", secret),
      ssl: {
        rejectUnauthorized: false,
        ca: getDatabaseCredential("certificate", secret),
      },
    });    
    try {
      await pgClient.connect();
      console.info('Succesfully connected to database');
      return pgClient;
    } catch (err) {
      console.error(`Error connecting to database: ${err.message}`);
      return undefined;
    }
  }
}

function getDatabaseCredential(
  fieldName: string,
  secret: { [key: string]: string }
): string {
  if (
    ![
      "username",
      "host",
      "port",
      "database_name",
      "password",
      "certificate",
    ].includes(fieldName)
  ) {
    throw new Error(`Unrecognized database credential field: "${fieldName}"`);
  }
  const ENV_VAR_NAME = `DB_SECRET_${fieldName.toUpperCase()}`;
  let value;
  if (process.env.hasOwnProperty(ENV_VAR_NAME)) {
    value = process.env[ENV_VAR_NAME];
    console.log(
      `DbConnect: found local value for database credential field "${fieldName}"`
    );
  }
  if (!value) {
    value = secret[fieldName];
  }
  if (!value) {
    throw new Error(
      `Value for database credential field "${fieldName}" must be set`
    );
  }
  return value;
}

async function getSecretValue(secretName: string): Promise<{[key:string]:string}> {
  const client = new SecretsManagerClient();
  const response = await client.send(
    new GetSecretValueCommand({
      SecretId: secretName,
    }),
  );
  return JSON.parse(response.SecretString);
};
