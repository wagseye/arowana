"use strict";

import DbObject from "./db_object.js";
import DbObjectField, {
  DbObjectStringField,
  DbObjectIdField,
  DbObjectNumberField,
  DbObjectReferenceField,
} from "./db_object_field.js";
//import DbObjectType from "./db_object_type.js";
import { DbFieldMapper } from "./db_decorators.js";
import Id from "./id.js";
import Timer from "./timer.js";

export class QueryResult {}

export class AggregateQueryResult extends QueryResult {}

export class ObjectQueryResult extends QueryResult {
  #records: DbObject[] = [];

  public constructor(proto: Object) {
    super();
  }
}

export default class Query<T extends DbObject> {
  #filterClause = new FilterClause();
  #sortClause = new SortClause();
  #limitClause = new LimitClause();
  #proto: Object;
  //#objType: DbObjectType;
  #joins: JoinClause[] = [];
  #table: TableReference;
  #allTables: TableReference[] | undefined;
  //#tablesByAlias: Map<string | undefined, TableReference> = new Map();

  static #database: any;
  static async loadDatabase() {
    try {
      // The module name is defined separately from the import to avoid tsc compilation errors
      console.log('Attempting to load database module');
      const module_name = "database-connector";
      const t: Timer = new Timer().start();
      const { default: Database } = await import(module_name);
      console.log(`Loaded module in ${t.stop().elapsedTime()}`);
      this.#database = Database;
    } catch (ex: unknown) {
      if (ex instanceof Error) {
        console.log(`Unable to load database module: ${ex.message}`);
      } else {
        console.log("Unable to load database module");
      }
    }
  }

  constructor(proto: Object) {
    if (!proto) {
      throw new Error("An object prototype must be specified in Query.constructor");
    }
    console.log(`In Query.constructor, class=${proto['name']}`);

    this.#proto = proto;
    this.#table = new TableReference(proto);
  }

  select(
    fields: DbObjectField | DbObjectField[] | string | string[]
  ): Query<T> {
    this.#table.addFields(fields);
    return this;
  }

  public where(filter: QueryFilter): Query<T> {
    this.#filterClause.add(filter);
    return this;
  }

  sort(...fields: unknown[]): Query<T> {
    this.#sortClause.addSortFields(...fields);
    return this;
  }

  limit(count: unknown): Query<T> {
    this.#limitClause.setLimit(count);
    return this;
  }

  join(reference: Readonly<DbObjectReferenceField>): Query<T> {
    if (!reference) {
      throw new Error("A reference field must be specified");
    }
    if (!(reference instanceof DbObjectReferenceField)) {
      throw new Error("The parameter to join() must be a reference field");
    }
    const subJoin = new JoinClause(reference, this.#table);
    this.#joins.push(subJoin);
    this.#table.addRelation(reference, subJoin.table);
    return this;
  }

  async all(): Promise<T[]> {
    let res: { [index: string]: any }[] = await Query.execute(this.toString());
    // Reverse the tables array to get the deepest descendants first, ending with this table.
    // This is so that as we populate the objects we should already have the child objects created
    // to be populated in the forward relationships.
    const tables: Array<TableReference> = this.#allTables!.toReversed();

    //const newObjsByAlias: { [key: string]: DbObject } = {};
    console.log("Results: " + res.length);
    // Iterate over each row of results
    res.forEach((row: { [index: string]: any }) => {
      // Iterate over each table (representing an individual object in the result row)
      tables.forEach((tbl: TableReference) => {
        const idName: string = tbl.getQualifiedFieldName(DbObject.id.fieldName);
        const objId: string = row[idName];
        let newObj = tbl.getNewObject(objId) ?? tbl.createNewObject(objId);
        // Iterate over all of the fields on the table and get the values from the result row
        tbl.qualifiedFields.forEach((fldName) => {
          const dbField = tbl.getDbField(fldName);
          if (!dbField) {
            throw new Error(`Did not find db field with name ${fldName}`);
          }
          if (!(fldName in row!))
            throw new Error(`Results do not have column named ${fldName}`);
          dbField.unmarshall(row![fldName], newObj);
        });
        // Go through and create any relations
        if (tbl.relations()) {
          for (const [relField, childTable] of tbl.relations()!) {
            const childId = newObj.get(relField.fieldName);
            if (childId) {
              const child = childTable.getNewObject(childId);
              if (!child) {
                throw new Error(
                  `Unable to find child object with id=${childId}`
                );
              }
              newObj.set(relField.relationName, child);
            }
          }
        }
      });
    });
    // @ts-ignore (Don't know how to dynamically type this correctly)
    return this.#table.newObjects;
  }

  async count(): Promise<number> {
    let q = this.toString();
    // TODO: this is a major hack. A better way must be found...
    q = q.replace(/^SELECT .* FROM /, 'SELECT count(*) FROM ');
    let res: { [index: string]: any }[] = await Query.execute(q);
    if (!res || !res.length || !res[0] || !('count' in res[0])) {
      throw new Error('Unknown error while counting records');
    }
    return parseInt(res[0]['count']);
  }

  toString(): string {
    let queryString = "SELECT";

    const joins: JoinClause[] = [];
    this.#allTables = [this.#table];
    //const tables: TableReference[] = [this.#table];
    if (this.#joins && this.#joins.length) {
      this.#joins.forEach((join: JoinClause) => {
        joins.push(...join.getJoins());
        this.#allTables!.push(...join.getJoinTables());
      });
    }
    JoinClause.createTableAliases(this.#allTables);

    const qualifiedFields: string[] = [];
    qualifiedFields.push(...this.#table.aliasedFields);
    joins.forEach((join) => {
      qualifiedFields.push(...join.getFields());
    });
    queryString += ` ${qualifiedFields.join(", ")}`;

    queryString += ` FROM ${this.#table.tableName}`;
    if (this.#table.tableAlias) queryString += ` ${this.#table.tableAlias}`;

    if (this.#joins && this.#joins.length) {
      this.#joins.forEach((join: JoinClause) => {
        queryString += ` ${join.getJoinString()}`;
      });
    }

    queryString += this.#filterClause.toString(this.#table.tableAlias);
    queryString += this.#sortClause.toString(this.#table.tableAlias);
    queryString += this.#limitClause.toString(this.#table.tableAlias);

    return queryString;
  }

  private static async execute(q: string): Promise<{ [index: string]: any }[]>
  {
    if (!this.#database) {
      await this.loadDatabase();
    }
    const t = new Timer().start();
    const res = await this.#database!.query(q);
    console.log(`Executed query in ${t.stop().elapsedTime()}`);
    return res;
  }
}

abstract class QueryClause {
  // TODO: This is somewhat duplicated in TableReference--what's the best place for it?
  protected getQualifiedFieldName(
    fldName: string,
    tableName: string | undefined
  ): string {
    if (tableName) return `${tableName}.${fldName}`;
    return fldName;
  }

  abstract toString(tableName?: string): string;
}

export class QueryFilter extends QueryClause {
  #join?: "AND" | "OR";
  #subFilters?: QueryFilter[];

  and(...otherFilters: QueryFilter[]): QueryFilter {
    const filter = new QueryFilter();
    filter.#join = "AND";
    filter.#subFilters ??= [];
    filter.#subFilters.push(this);
    filter.#subFilters.push(...otherFilters);
    return filter;
  }

  or(...otherFilters: QueryFilter[]): QueryFilter {
    const filter = new QueryFilter();
    filter.#join = "OR";
    filter.#subFilters ??= [];
    filter.#subFilters.push(this);
    filter.#subFilters.push(...otherFilters);
    return filter;
  }

  toString(tableName?: string): string {
    const separator = ` ${this.#join} `;
    if (this.#subFilters) {
      const qualifiedSubFilters: string[] = [];
      this.#subFilters.forEach((subFilter: QueryFilter) => {
        qualifiedSubFilters.push(subFilter.toString(tableName));
      });
      return `(${qualifiedSubFilters.join(separator)})`;
    }
    return "";
  }
}

export class QueryComparisonFilter extends QueryFilter {
  #field: DbObjectField;
  #operator: string;
  #values: Array<unknown>;

  constructor(
    fld: DbObjectField,
    op: string,
    vals: DbObjectField | string | string[]
  ) {
    super();

    const values = vals instanceof Array ? vals : [vals];
    this.validateField(fld);
    this.#field = fld;
    this.validateOperator(fld, op);
    this.#operator = op;
    this.validateValues(fld, op, values);
    this.#values = values;
  }

  private validateField(field: DbObjectField): boolean {
    if (!field) throw new Error("No DbObjectField provided");
    if (!(field instanceof DbObjectField))
      throw new Error(
        "The first argument must be an instance of DbObjectField"
      );
    return true;
  }

  private validateOperator(field: DbObjectField, operator: string): boolean {
    if (
      field instanceof DbObjectStringField &&
      !new Set<string>(["=", "<>"]).has(operator)
    ) {
      throw new Error("String fields can only use == or <> comparisons");
    }
    if (
      field instanceof DbObjectIdField &&
      !new Set<string>(["=", "<>"]).has(operator)
    ) {
      throw new Error("Id fields can only use == or <> comparisons");
    }
    if (
      field instanceof DbObjectNumberField &&
      !new Set<string>(["=", "<>", "<", "<=", ">", ">="]).has(operator)
    ) {
      throw new Error(
        "Id fields can only use the following comparisons: =, <>, <, <=, >, >="
      );
    }
    return true;
  }

  private validateValues(
    field: DbObjectField,
    operator: string,
    values: unknown[]
  ): boolean {
    const isList = values.length > 1;

    if (field instanceof DbObjectNumberField) {
      values.forEach((val: unknown) => {
        if (!val && operator !== "=" && operator !== "<>")
          throw new Error(
            "Numeric fields can only test equals/not equals with an empty value"
          );
        if (val && Number.isNaN(Number.parseFloat(val as string)))
          throw new Error(
            `Numeric field can not be compared to value '${val}'`
          );
      });
    } else if (field instanceof DbObjectIdField) {
      values.forEach((val: unknown) => {
        if (val && !(val instanceof Id)) {
          let isValid = false;
          try {
            new Id(val as string);
            isValid = true;
          } catch {}
          if (!isValid)
            throw new Error(`Id field can not be compared to value '${val}'`);
        }
      });
    }
    return true;
  }

  public toString(tableName?: string): string {
    // For equals comparisons, use "OR" logic, otherwise use "AND" (for not equals and lt/gt comparisons)
    const joinType: string = this.#operator === "=" ? "OR" : "AND";
    const conditions: string[] = [];
    const fieldName: string = this.getQualifiedFieldName(
      this.#field.fieldName,
      tableName
    );
    this.#values.forEach((val) => {
      if (!val) {
        if (this.#operator === "=") conditions.push(`${fieldName} IS NULL`);
        if (this.#operator === "<>")
          conditions.push(`${fieldName} IS NOT NULL`);
      } else {
        let formattedValue = val;
        if (
          this.#field instanceof DbObjectStringField ||
          this.#field instanceof DbObjectIdField
        ) {
          formattedValue = `'${val}'`;
        }
        // CRITICAL: This MUST be updated to use prepared statements or some other safety mechanism
        conditions.push(`${fieldName}${this.#operator}${formattedValue}`);
      }
    });

    if (!conditions.length) return "";
    if (conditions.length == 1) return conditions[0];
    return `(${conditions.join(` ${joinType} `)})`;
  }
}

// TODO: better name for this class?
class TableReference {
 // #objectType: DbObjectType;
  #proto: Object;
  #tableAlias: string = "";
  #newObjects: DbObject[] = [];
  #newObjectMap: Map<string, DbObject> = new Map();
  #parentTable: TableReference | undefined;
  #relations: Map<Readonly<DbObjectReferenceField>, TableReference> | undefined;
  #fields: Readonly<DbObjectField>[] = [];
  #fieldMap: Map<string, Readonly<DbObjectField>> = new Map();

  constructor(
    proto: Object,
    parent: TableReference | undefined = undefined
  ) {
    if (!proto) {
      throw new Error("An object prototype type must be specified");
    }
    this.#proto = proto;
    // console.log(`In TableReference.constructor, class=${this.#proto['name']}`);
    console.log(`In TableReference.constructor, class=${JSON.stringify(Object.getOwnPropertyDescriptors(proto))}`);
    this.#parentTable = parent;
  }

  public get proto(): Object {
    return this.#proto;
  }
  public get tableName(): string {
    return this.#proto['tableName'];
  }
  public get tableAlias(): string {
    return this.#tableAlias;
  }

  public set tableAlias(value) {
    this.#tableAlias = value;
  }

  public get fields(): Readonly<DbObjectField>[] {
    if (!this.#fields.length) {
      const dbFields = DbFieldMapper.getFields(this.#proto);
      if (!dbFields || !dbFields.size) {
        throw new Error("Did not find object field map from object type");
      }
      for (const [key, value] of dbFields) {
        this.#fields.push(value);
        this.#fieldMap.set(key, value);
      }
    } else {
      // If the user specified the fields to retrieve, ensure the id field part of the list
      if (!this.#fieldMap.has(DbObject.id.fieldName)) {
        this.#fields.push(DbObject.id);
        this.#fieldMap.set(DbObject.id.fieldName, DbObject.id);
      }
    }
    return this.#fields;
  }

  public addFields(flds: DbObjectField | DbObjectField[] | string | string[]) {
    const arr = flds instanceof Array ? flds : [flds];

    const dbFieldMap = DbFieldMapper.getFields(this.#proto);
    if (!dbFieldMap) {
      throw new Error("Did not find object field map from object type");
    }

    let fldArray: DbObjectField[] = Array.from(arr, (fld) => {
      if (typeof fld === "string") {
        const dbField = dbFieldMap.get(fld);
        if (!dbField) throw new Error(`There is no field named ${fld}`); // TODO: we really need a way to print the object name here
        return dbField;
      }
      return fld;
    });
    this.#fields.push(...fldArray);
    fldArray.forEach((fld) => this.#fieldMap.set(fld.fieldName, fld));
  }

  public get newObjects(): DbObject[] {
    return this.#newObjects;
  }

  public getNewObject(objId: string | Id): DbObject | undefined {
    if (!objId) throw new Error("No id specified");
    return this.#newObjectMap.get(objId.toString());
  }

  public createNewObject(objId: string | Id): DbObject {
    if (!objId) throw new Error("No id specified");
    const idStr = objId.toString();
    if (this.#newObjectMap?.has(idStr)) {
      throw new Error("Object with that id already exists");
    }
    // @ts-ignore
    const newObj = this.#proto.newInstance();
    console.log(`In Query.createNewObject, isDbObject=${newObj instanceof DbObject}`);
    console.log(`In Query.createNewObject, proto name=${Object.getPrototypeOf(newObj).name}`);
    console.log(`In Query.createNewObject, proto proto name=${Object.getPrototypeOf(Object.getPrototypeOf(newObj)).name}`);
    console.log(`In Query.createNewObject ${JSON.stringify(newObj)}`);
    newObj.id = new Id(idStr);
    this.#newObjects.push(newObj);
    this.#newObjectMap.set(idStr, newObj);
    return newObj;
  }

  public relations():
    | Map<Readonly<DbObjectReferenceField>, TableReference>
    | undefined {
    return this.#relations; // Maybe return a copy? Should be ok because this is all internal...
  }

  public addRelation(
    refFld: Readonly<DbObjectReferenceField>,
    child: TableReference
  ) {
    this.#relations ??= new Map();
    this.#relations.set(refFld, child);
  }

  public getDbField(fldName: string): Readonly<DbObjectField> | undefined {
    return this.#fieldMap.get(fldName.split(".").slice(-1)[0]);
  }

  public get qualifiedFields(): string[] {
    return this.fields.map((fld) => this.getQualifiedFieldName(fld.fieldName));
  }

  public get aliasedFields() {
    const qualifiedFields = this.qualifiedFields;
    if (!this.#tableAlias) return qualifiedFields;
    return qualifiedFields.map((fld) => `${fld} AS "${fld}"`);
  }

  public getQualifiedFieldName(fldName: string): string {
    return this.tableAlias ? `${this.tableAlias}.${fldName}` : fldName;
  }
}

export class SortOrder {
  static up: Symbol = Object.freeze(Symbol("ASC"));
  static down: Symbol = Object.freeze(Symbol("DESC"));
}

export class JoinClause extends QueryClause {
  #table: TableReference;
  #parentTable: TableReference;
  #filterClause = new FilterClause();
  #subJoins: JoinClause[] = [];
  #referenceField: Readonly<DbObjectReferenceField>;

  constructor(
    reference: Readonly<DbObjectReferenceField>,
    parentTable: TableReference
  ) {
    super();
    this.#referenceField = reference;
    this.#table = new TableReference(reference.referenceType, parentTable);
    this.#parentTable = parentTable;
  }

  public select(fields: string | string[]): JoinClause {
    this.#table.addFields(fields);
    return this;
  }

  public where(filter: QueryFilter): JoinClause {
    this.#filterClause.add(filter);
    return this;
  }

  join(reference: Readonly<DbObjectReferenceField>): JoinClause {
    if (!reference) {
      throw new Error("A reference field must be specified");
    }
    const subJoin = new JoinClause(reference, this.#table);
    this.#subJoins.push(subJoin);
    this.#table.addRelation(reference, subJoin.table);
    return this;
  }

  get table(): TableReference {
    return this.#table;
  }

  getFields(): string[] {
    return this.#table.aliasedFields;
  }

  getAllJoins(): JoinClause[] {
    const joins: JoinClause[] = [this];
    this.#subJoins.forEach((subJoin: JoinClause) => {
      joins.push(...subJoin.getAllJoins());
    });
    return joins;
  }

  getJoins(): JoinClause[] {
    const joins: JoinClause[] = [this];
    this.#subJoins.forEach((subJoin: JoinClause) => {
      joins.push(...subJoin.getJoins());
    });
    return joins;
  }

  getJoinTables(): TableReference[] {
    // The code that populates the DbObjects relies on the tables being ordered highest to lowest in
    // the hierarchy so we add this table first then all descendants
    const tables: TableReference[] = [this.#table];
    this.#subJoins.forEach((subJoin: JoinClause) => {
      tables.push(...subJoin.getJoinTables());
    });
    return tables;
  }

  getJoinString(): string {
    let output: string = "LEFT OUTER JOIN";
    output += ` ${this.#table.tableName} ${this.#table.tableAlias} ON ${
      this.#parentTable.tableAlias
    }.${this.#referenceField.fieldName}=${this.#table.tableAlias}.${
      this.#referenceField.foreignField
    }`;
    return output;
  }

  public static createTableAliases(tables: TableReference[]): void {
    // If there's only one table there's not ambiguity so we don't need any aliasing
    if (tables.length > 1) {
      const tablesByInitial: { [key: string]: TableReference[] } = {};
      tables.forEach((table: TableReference) => {
        const key = table.tableName!.charAt(0);
        tablesByInitial[key] ??= [];
        tablesByInitial[key].push(table);
      });
      Object.keys(tablesByInitial).forEach((initial: string) => {
        const tbls = tablesByInitial[initial];
        if (tbls.length == 1) {
          tbls[0].tableAlias = initial;
        } else {
          tbls.forEach((tbl: TableReference, idx: number) => {
            tbl.tableAlias = `${initial}${idx + 1}`;
          });
        }
      });
    } else {
      tables[0].tableAlias = "";
    }
  }

  // This is required for QueryClause. We can probably make it useful but it's just a stub for now
  toString(tableName?: string): string {
    return "";
  }
}

/*
export class FieldClause extends QueryClause {
  #fields: string[] = [];
  #objType: DbObjectType;

  constructor(objType: DbObjectType) {
    super();
    this.#objType = objType;
  }

  add(flds: DbObjectField | DbObjectField[] | string | string[]) {
    const fldArray = flds instanceof Array ? flds : [flds];
    this.#fields ??= [];
    let strArray: string[] = Array.from(fldArray, (fld) => {
      if (fld instanceof DbObjectField) return fld.fieldName;
      return fld;
    });
    this.#fields.push(...strArray);
  }

  getFields(tableName?: string): string[] {
    const qualifiedFields = Array.from(this.#fields, (fldName) =>
      this.getQualifiedFieldName(fldName, tableName)
    );
    if (!qualifiedFields.length) {
      const dbFields = DbFieldMapper.getFields(this.#objType);
      if (dbFields && dbFields.size) {
        for (const [key, value] of dbFields) {
          qualifiedFields.push(this.getQualifiedFieldName(key, tableName));
        }
      } else {
        console.error("Did not find object field map from object type");
        qualifiedFields.push(this.getQualifiedFieldName("*", tableName));
      }
    }
    return qualifiedFields;
  }

  toString(tableName?: string): string {
    return this.getFields(tableName).join(", ");
  }
}
*/

export class FilterClause extends QueryClause {
  #filters: QueryFilter[] = [];

  public add(filter: QueryFilter): void {
    this.#filters.push(filter);
  }

  public toString(tableName?: string): string {
    let output: string = "";
    if (this.#filters && this.#filters.length) {
      const conditions: string[] = [];
      this.#filters.forEach((filter: QueryFilter) => {
        conditions.push(filter.toString(tableName));
      });
      if (conditions.length) {
        output += ` WHERE ${conditions.join(" AND ")}`;
      }
    }
    return output;
  }
}

class SortClause extends QueryClause {
  #sortFields: [{ [key: string]: Symbol }?] = [];

  addSortFields(...fields: unknown[]): void {
    fields.forEach((fld: unknown) => {
      if (fld instanceof DbObjectField) {
        this.#sortFields!.push({ [fld.fieldName]: SortOrder.up });
      } else if (typeof fld === "string") {
        this.#sortFields!.push({ [fld]: SortOrder.up });
      } else if (typeof fld === "object") {
        const obj = fld as { [key: string]: string | Symbol };
        const keys: string[] = Object.keys(obj);
        if (keys.length != 1) {
          throw new Error(
            "Object paramters to sort() must have a single key/value pair"
          );
        }
        let fldName: string = keys[0];
        let value = obj[fldName];
        const valueType = typeof value;
        if (valueType !== "symbol" && valueType !== "string") {
          throw new Error(
            "The value of a sort specification must be SortOrder.up or SortOrder.down" // I'm just bluffing
          );
        }
        if (valueType == "symbol") {
          if (value !== SortOrder.up && value !== SortOrder.down) {
            throw new Error(
              "The value of a sort specification must be SortOrder.up or SortOrder.down"
            );
          }
          this.#sortFields!.push({ [fldName]: value });
        } else if (valueType === "string") {
          // See, I told you I was bluffing!
          if (
            new Set([
              "up",
              "down",
              "asc",
              "desc",
              "ascending",
              "descending",
            ]).has(value as string)
          ) {
            throw new Error(
              'The value of a sort specification must be "up" or "down"'
            );
          }
          if (new Set(["down", "desc", "descending"]).has(value as string)) {
            this.#sortFields!.push({ [fldName]: SortOrder.down });
          } else {
            this.#sortFields!.push({ [fldName]: SortOrder.up });
          }
        } else {
          throw new Error(
            "OrderBy parameters must be of type string or DbObjectField"
          );
        }
      }
    });
  }

  toString(tableName?: string): string {
    if (this.#sortFields.length) {
      const expandedValues: string[] = [];
      this.#sortFields.forEach(
        (sortField: { [key: string]: Symbol } | undefined) => {
          const keys: string[] = Object.keys(sortField!);
          expandedValues.push(
            `${this.getQualifiedFieldName(keys[0], tableName)}${
              sortField![keys[0]] == SortOrder.down ? " DESC" : ""
            }`
          );
        }
      );
      return ` ORDER BY ${expandedValues.join(", ")}`;
    }
    return "";
  }
}

class LimitClause extends QueryClause {
  #limit?: number;

  setLimit(count: unknown): void {
    if (count !== parseInt(count as string, 10)) {
      throw new Error("Limit value must be an integer");
    }
    if (count <= 0) throw new Error("Limit must be greater than zero");
    this.#limit = count;
  }

  toString(tableName?: string): string {
    if (this.#limit) {
      return ` LIMIT ${this.#limit}`;
    }
    return "";
  }
}
