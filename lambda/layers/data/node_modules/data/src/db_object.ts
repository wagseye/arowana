"use strict";

import Id from "./id.js";
//import DbObjectType from "./db_object_type.js";
import DbObjectField, { DbObjectIdField } from "./db_object_field.js";
import Query from "./query.js";
import { dbField } from "./db_decorators.js";

export interface PrototypeType<T> extends Function {
  prototype: T;
}

export interface ConstructorFunctionType<T = any> extends PrototypeType<T> {
  new (...args: any[]): T;
}

export type ConstructorType<
  T = unknown,
  Static extends Record<string, any> = PrototypeType<T>
> = (ConstructorFunctionType<T> | PrototypeType<T>) & {
  [Key in keyof Static]: Static[Key];
};

export default class DbObject {
  @dbField
  static id: DbObjectField = new DbObjectIdField("id");

  #props = new Map();

  constructor() {
    if (this.constructor == DbObject) {
      throw new Error('DbObject class is abstract and can not be instantiated.');
    }
  }

  static get class(): Object {
    return this;
  }

  get class(): Object {
    return Object.getPrototypeOf(this).constructor.class;
  }

  static newInstance<T extends DbObject>(): T {
    const proto: any = this.class;
    console.log(`In newInstance, about to introspect proto`);
    console.log(`In newInstance, proto=${JSON.stringify(Object.getOwnPropertyDescriptors(proto))}`);
    console.log(`...and done!`);
      // This code was taken from here: https://stackoverflow.com/questions/4226646
      // I don't fully understand it, but I tried all sorts of combinations of Object.create(proto),
      // Object.setPrototypeOf(newObj, proto), etc. but could not get it to work any other way
      return new (proto.bind.apply(proto));
  }

  static idPrefix(): string {
    throw new Error('Static method "idPrefix" must be implemented by subclass');
  }

  static tableName(): string {
    throw new Error('Static method "tableName" must be implemented by subclass');
  }

  // Accessors for getting and setting properties
  public get(prop: string | DbObjectField): any {
    if (!(typeof prop === "string" || prop instanceof DbObjectField)) {
      throw new Error(
        "The specified property must be a string or DbObjectField"
      );
    }
    const propName = prop instanceof DbObjectField ? prop.fieldName : prop;
    return this.#props.get(propName);
  }

  public set(prop: string | DbObjectField, value: any): void {
    if (!(typeof prop === "string" || prop instanceof DbObjectField)) {
      throw new Error(
        "The specified property must be a string or DbObjectField"
      );
    }
    const propName = prop instanceof DbObjectField ? prop.fieldName : prop;
    this.#props.set(propName, value);
  }

  setString(prop: string | DbObjectField, value: any): void {
    if (value && typeof value !== "string" && !(value instanceof String)) {
      throw new Error("Property value must be a string");
    }
    this.#props.set(prop, value);
  }

  // Shared fields
  get id(): Id {
    return this.get(DbObject.id) as Id;
  }

  set id(value) {
    this.set(DbObject.id, value);
  }

  public toJson(): string {
    // Eventually we'll probably want to filter out some of these values
    return JSON.stringify(Object.fromEntries(this.#props));
  }

  // Query-related methods
  static select<T extends DbObject>(
    this: ConstructorType<T, typeof DbObject>,
    fields?: DbObjectField | DbObjectField[] | string | string[]
  ): Query<T> {
    console.log(`In DbObject.select, class=${this.class['name']}`);
    let q = new Query<T>(this.class);
    if (fields) {
      q.select(fields);
    }
    return q;
  }

  // Potential future methods
  /*
  static load(field: DbObjectReferenceField): DbObject? {
    return undefined;
  } */
}
