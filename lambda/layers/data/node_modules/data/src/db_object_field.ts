"use strict";

import { QueryFilter, QueryComparisonFilter } from "./query.js";
import { DbObjectMapper } from "./db_decorators.js";
import DbObject from "./db_object.js";
//import DbObjectType from "./db_object_type.js";
import Id from "./id.js";

export default abstract class DbObjectField {
  #fieldName: string;

  public get fieldName() {
    return this.#fieldName;
  }

  public constructor(fieldName: string) {
    if (!fieldName) throw new Error("A field name must be provided");
    this.#fieldName = fieldName;
  }

  protected abstract coerceType(value: unknown) : unknown;

  public unmarshall(value: string, obj: DbObject): void {
    obj.set(this.fieldName, this.coerceType(value));
  }

  public equals(value: any): QueryFilter {
    return new QueryComparisonFilter(this, "=", value);
  }

  public notEquals(value: any): QueryFilter {
    return new QueryComparisonFilter(this, "<>", value);
  }

  public greaterThan(value: any): QueryFilter {
    return new QueryComparisonFilter(this, ">", value);
  }

  public greaterOrEqualThan(value: any): QueryFilter {
    return new QueryComparisonFilter(this, ">=", value);
  }

  public lessThan(value: any): QueryFilter {
    return new QueryComparisonFilter(this, "<", value);
  }

  public lessOrEqualThan(value: any): QueryFilter {
    return new QueryComparisonFilter(this, "<=", value);
  }

  public toString() {
    return this.#fieldName;
  }
}

export class DbObjectIdField extends DbObjectField {
  public constructor(fieldName: string) {
    super(fieldName);
  }

  protected coerceType(value: unknown) : unknown {
    if (value instanceof Id) return value;
    if (typeof value === "string") return new Id(value);
    throw new Error("Value of an id field must be an Id or string");
  }
/*
  public unmarshall(value: string, obj: DbObject): void {
    obj.set(this.fieldName, this.coerceType(value));
  }
*/
}

export class DbObjectStringField extends DbObjectField {
  public constructor(fieldName: string) {
    super(fieldName);
  }

  protected coerceType(value: unknown) : unknown {
    if (typeof value === "string") return value;
    if (value instanceof Id) return value.toString();
    throw new Error("Value of an string must be a string");
  }
  // public unmarshall(value: string, obj: DbObject): void {
  //   obj.set(this.fieldName, value);
  // }
}

export class DbObjectNumberField extends DbObjectField {
  #decimalPlaces = 0;
  public constructor(fieldName: string, decimalPlaces: number) {
    super(fieldName);
    this.#decimalPlaces = decimalPlaces;
  }
  protected coerceType(value: unknown) : unknown {
    if (typeof value === "number") return value;
    try {
      if (typeof value === "string") return Number.parseFloat(value).toFixed(this.#decimalPlaces);
    } catch (err: unknown) {
      throw new Error('Invalid number format');
    }
    throw new Error("Value of an number field must be a number");
  }
  // public unmarshall(value: string, obj: DbObject): void {
  //   obj.set(
  //     this.fieldName,
  //     Number.parseFloat(value).toFixed(this.#decimalPlaces)
  //   );
  // }
}

export class DbObjectIntegerField extends DbObjectNumberField {
  public constructor(fieldName: string) {
    super(fieldName, 0);
  }
  protected coerceType(value: unknown) : unknown {
    if (typeof value === "number") return value.toFixed();
    try {
      if (typeof value === "string") return Number.parseInt(value);
    } catch (err: unknown) {
      throw new Error('Invalid integer format');
    }
    throw new Error("Value of an integer field must be a number");
  }
  // public unmarshall(value: string, obj: DbObject): void {
  //   obj.set(this.fieldName, Number.parseInt(value));
  // }
}

export class DbObjectDateField extends DbObjectField {
  public constructor(fieldName: string) {
    super (fieldName)
  }
  protected coerceType(value: unknown) : unknown {
    if (value instanceof Date) return value;
    if (typeof value === "number") {
      // TODO: add additional checks here?
      return new Date(value);
    };
    try {
      if (typeof value === "string") return new Date(value);
    } catch (err: unknown) {
      throw new Error('Invalid date format');
    }
    throw new Error("Value can not be stored in a date field");
  }
  // public unmarshall(value: string, obj: DbObject): void {
  //   throw new Error('Not implemented');
  //   obj.set(this.fieldName, undefined);
  // }
}

export class DbObjectDateTimeField extends DbObjectField {
  public constructor(fieldName: string) {
    super (fieldName)
  }
  protected coerceType(value: unknown) : unknown {
    if (value instanceof Date) return value;
    if (typeof value === "number") {
      // TODO: add additional checks here?
      return new Date(value);
    };
    try {
      if (typeof value === "string") return new Date(value);
    } catch (err: unknown) {
      throw new Error('Invalid date format');
    }
    throw new Error("Value can not be stored in a datetime field");
  }
  // public unmarshall(value: string, obj: DbObject): void {
  //   throw new Error('Not implemented');
  //   obj.set(this.fieldName, undefined);
  // }
}
/*
class DbObjectReferenceRelation {
  //#table: TableReference;
  #joins: JoinClause[] = [];
  #filterClause = new FilterClause();
  #fieldClause = new FieldClause();

  join(
    ref: Readonly<DbObjectReferenceField> | Readonly<DbObjectReferenceRelation>
  ): DbObjectReferenceRelation {
    if (
      !(ref instanceof DbObjectReferenceField) &&
      !(ref instanceof DbObjectReferenceRelation)
    ) {
      throw new Error(
        "The parameter to join() must be a reference field or relation"
      );
    }
    //    this.#joins.push(new JoinClause(ref, this.#table));
    return this;
  }

  public where(filter: QueryFilter): DbObjectReferenceRelation {
    this.#filterClause.add(filter);
    return this;
  }

  select(fields: string | string[]): DbObjectReferenceRelation {
    this.#fieldClause.add(fields);
    return this;
  }
}
*/
export class DbObjectReferenceField extends DbObjectIdField {
  #proto: Object | undefined;
  #proto_name: string;
  #relationName: string;
  #foreignFieldName: string;
  #foreignRelationName: string | undefined;

  public constructor(
    fieldName: string,
    proto_name: string,
    relationName: string,
    foreignRelation: string | undefined = undefined,
    foreignField: string = "id"
  ) {
    if (!proto_name) {
      throw new Error(
        "Object prototype name must be provided to create a DbObjectReferenceField object"
      );
    }
    if (!foreignField) {
      throw new Error(
        "Reference field must be provided to create a DbObjectReferenceField object"
      );
    }
    super(fieldName);
    this.#proto_name = proto_name;
    this.#relationName = relationName;
    this.#foreignFieldName = foreignField;
    this.#foreignRelationName = foreignRelation;
  }

  public get referenceType(): Object {
    if (!this.#proto)
    {
      this.#proto = DbObjectMapper.getObject(this.#proto_name);
      if (!this.#proto) throw new Error(`Could not resolve class with name ${this.#proto_name}`);
    }
    return this.#proto;
  }

  public get foreignField(): string {
    return this.#foreignFieldName;
  }

  public get relationName(): string {
    return this.#relationName;
  }

  public get foreignRelationName(): string | undefined {
    return this.#foreignRelationName;
  }

  // NB: How do we store the actual reference to the related object?

  // protected coerceType(value: unknown) : unknown {
  //   if (value instanceof DbObject) return value;
  //   throw new Error("Value of an id field must be an Id or string");
  // }
}
